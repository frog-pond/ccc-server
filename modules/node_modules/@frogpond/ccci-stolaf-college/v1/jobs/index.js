import {get, ONE_DAY} from '@frogpond/ccc-lib'
import mem from 'mem'
import pMap from 'p-map'
import _jsdom from 'jsdom'
import getUrls from 'get-urls'

const {JSDOM} = _jsdom

const jobsUrl = 'https://wp.stolaf.edu/student-jobs/wp-json/wp/v2/pages/80'

const PARAGRAPHICAL_KEYS = [
	'Job Description',
	'Skills Needed',
	'Additional Comments',
	'How to Apply',
	'Hiring Timeline',
]

async function fetchDetail(url) {
	const resp = await get(url)

	// run-scripts value is needed to properly evaluate javascript to display an email address.
	// see the jsdom documentation for more details https://github.com/jsdom/jsdom#executing-scripts
	const dom = new JSDOM(resp.body, {
		contentType: 'text/html',
		runScripts: 'dangerously',
	})

	const id = url.replace(/\D/g, '')
	const titleText = dom.window.document.querySelector(
		'.gv-list-view-title > h3',
	).textContent
	const details = dom.window.document.querySelectorAll('div')

	const detailMap = [...details].reduce((coll, listEl) => {
		let [key, ...value] = listEl.childNodes
		key = key ? key.textContent.replace(/:$/, '') : key

		if (PARAGRAPHICAL_KEYS.includes(key)) {
			let paragraphs = [...listEl.querySelectorAll('p')]
			let content = paragraphs.length ? paragraphs : value
			value = content
				.map((el) => el.textContent)
				.join('\n\n')
				.trim()
		} else {
			value = value
				.map((el) => el.textContent)
				.join(' ')
				.trim()
		}
		coll.set(key, value)

		return coll
	}, new Map())

	function findKey(value) {
		return detailMap.get(value) || ''
	}

	const [contactFirstName, contactLastName] =
		findKey('Contact Person').split(' ')
	const contactName = `${contactFirstName} ${contactLastName}`.trim()

	const description = cleanTextBlock(findKey('Job Description'))
	const comments = cleanTextBlock(findKey('Additional Comments'))
	const skills = cleanTextBlock(findKey('Skills Needed'))
	const howToApply = cleanTextBlock(findKey('How to Apply'))
	const timeline = cleanTextBlock(findKey('Hiring Timeline'))

	const links = getLinksFromJob({description, comments, skills, howToApply})

	return {
		comments: comments,
		contactEmail: fixupEmailFormat(findKey('Contact Email')),
		contactName: contactName,
		contactPhone: fixupPhoneFormat(findKey('Phone Extension')),
		description: description,
		goodForIncomingStudents: Boolean(
			findKey('Appropriate for incoming/first-year students'),
		),
		hoursPerWeek: findKey('Hours/week'),
		howToApply: howToApply,
		id: id,
		lastModified: findKey('Date Posted'),
		links: links,
		office: findKey('Office'),
		openPositions: findKey('Number of Available Positions'),
		skills: skills,
		timeline: timeline,
		timeOfHours: findKey('Time of Hours'),
		title: titleText,
		type: findKey('Job Type'),
		url: url,
		year: findKey('Job Year'),
	}
}

function cleanTextBlock(text) {
	return text.replace(/\s+/g, ' ')
}

export function getLinksFromJob({description, comments, skills, howToApply}) {
	// Clean up returns, newlines, tabs, and misc symbols...
	// ...and search for application links in the text
	return Array.from(
		new Set([
			...getUrls(description),
			...getUrls(comments),
			...getUrls(skills),
			...getUrls(howToApply),
		]),
	)
}

function fixupPhoneFormat(phoneNumber) {
	return phoneNumber.length === 4 ? `507-786-${phoneNumber}` : phoneNumber
}

function fixupEmailFormat(email) {
	if (!/@/.test(email)) {
		// No @ in address ... e.g. smith
		return `${email}@stolaf.edu`
	} else if (/@$/.test(email)) {
		// @ at end ... e.g. smith@
		return `${email}stolaf.edu`
	} else {
		// Defined address ... e.g. smith@stolaf.edu
		return email
	}
}

function nextPageExists(dom) {
	if (dom === undefined) {
		return false
	}

	const elements = dom.window.document.querySelectorAll('.next.page-numbers')
	return elements.length > 0
}

export function findPageUrls(dom) {
	const jobLinks = Array.from(
		dom.window.document.querySelectorAll(
			'.gv-list-view > .gv-list-view-title > h3 > a',
		),
	).map((url) => url.getAttribute('href'))

	return jobLinks
}

/**
 * The coldfusion endpoint stopped providing a robust json api response and started serving
 * a much rougher wp-json endpoint according to our logs on 09/27/2022. Implementation as of
 * 10/16/2022 is designed around making a series of network requests that involve both json
 * and html parsing to deliver the same set of props to match the client's api contract.
 *
 * In short, we are performing the following fetching and parsing steps:
 * 1. [json] wp-json paginated requests to get page urls (1-3 requests for 25->50->75 entries)
 *           where we target html stored within a json field response
 * 2. [html] detail page html requests, involves html parsing and returning json (easily 50+ requests)
 *
 * So we end up making multiple requests to the paginated wp-json endpoint to build a list of
 * all job posting urls, and finally request each url we find to build our data.
 */
async function _getJobs() {
	let allUrls = []

	/**
	 * The top-level wp-json endpoint which provides the list of job postings responds to a query
	 * parameter named `pagenum`. The paginator as of 10/16/2022 lists 25 entries at a time, so if
	 * we see 51 entries, we would expect to query this endpoint three times.
	 */
	let pageNumber = 1

	let previousDom = undefined

	do {
		const response = await get(`${jobsUrl}?pagenum=${pageNumber}`, {json: true})
		const {rendered} = response.body.content

		const dom = new JSDOM(rendered, {contentType: 'text/html'})
		previousDom = dom
		pageNumber += 1

		const fetchedUrls = findPageUrls(dom)
		allUrls.push(...fetchedUrls)
	} while (nextPageExists(previousDom))

	return pMap(allUrls, fetchDetail, {concurrency: 4})
}

export const getJobs = mem(_getJobs, {maxAge: ONE_DAY})

export async function jobs(ctx) {
	ctx.cacheControl(ONE_DAY)

	ctx.body = await getJobs()
}
