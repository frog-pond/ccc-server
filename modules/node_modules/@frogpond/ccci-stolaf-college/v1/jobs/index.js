import {get, ONE_DAY} from '@frogpond/ccc-lib'
import mem from 'mem'
import pMap from 'p-map'
import _jsdom from 'jsdom'
import getUrls from 'get-urls'

const {JSDOM} = _jsdom

const jobsUrl =
	'https://wp.stolaf.edu/student-jobs/wp-json/wp/v2/pages/80'

const PARAGRAPHICAL_KEYS = ['Job Description', 'Skills Needed', 'Additional Comments', 'How to Apply', 'Hiring Timeline']

async function fetchDetail(url) {
	const resp = await get(url)

	// run-scripts value is needed to properly evaluate javascript to display an email address.
	// see the jsdom documentation for more details https://github.com/jsdom/jsdom#executing-scripts
	const dom = new JSDOM(resp.body, {contentType: 'text/html', runScripts: 'dangerously' })

	const id = url.replace(/\D/g,'')
	const titleText = dom.window.document.querySelector('.gv-list-view-title > h3').textContent
	const details = dom.window.document.querySelectorAll('div')

	const detailMap = [...details].reduce((coll, listEl) => {
		let [key, ...value] = listEl.childNodes
		key = key ? key.textContent.replace(/:$/, '') : key

		if (PARAGRAPHICAL_KEYS.includes(key)) {
			let paragraphs = [...listEl.querySelectorAll('p')]
			let content = paragraphs.length ? paragraphs : value
			value = content
				.map((el) => el.textContent)
				.join('\n\n')
				.trim()
		} else {
			value = value
				.map((el) => el.textContent)
				.join(' ')
				.trim()
		}
		coll.set(key, value)

		return coll
	}, new Map())

	function findKey(value) {
		return detailMap.get(value) || ''
	}

	const [contactFirstName, contactLastName] = findKey('Contact Person').split(' ')
	const contactName = `${contactFirstName} ${contactLastName}`.trim()

	const description = cleanTextBlock(findKey('Job Description'))
	const comments = cleanTextBlock(findKey('Additional Comments'))
	const skills = cleanTextBlock(findKey('Skills Needed'))
	const howToApply = cleanTextBlock(findKey('How to Apply'))
	const timeline = cleanTextBlock(findKey('Hiring Timeline'))

	const links = getLinksFromJob({description, comments, skills, howToApply})

	return {
		comments: comments,
		contactEmail: fixupEmailFormat(findKey('Contact Email')),
		contactName: contactName,
		contactPhone: fixupPhoneFormat(findKey('Phone Extension')),
		description: description,
		goodForIncomingStudents: Boolean(findKey('Appropriate for incoming/first-year students')),
		hoursPerWeek: findKey('Hours/week'),
		howToApply: howToApply,
		id: id,
		lastModified: findKey('Date Posted'),
		links: links,
		office: findKey('Office'),
		openPositions: findKey('Number of Available Positions'),
		skills: skills,
		timeline: timeline,
		timeOfHours: findKey('Time of Hours'),
		title: titleText,
		type: findKey('Job Type'),
		url: url,
		year: findKey('Job Year'),
	}
}

function cleanTextBlock(text) {
	return text.replace(/\s+/g, ' ')
}

export function getLinksFromJob({description, comments, skills, howToApply}) {
	// Clean up returns, newlines, tabs, and misc symbols...
	// ...and search for application links in the text
	return Array.from(
		new Set([
			...getUrls(description),
			...getUrls(comments),
			...getUrls(skills),
			...getUrls(howToApply),
		]),
	)
}

function fixupPhoneFormat(phoneNumber) {
	return phoneNumber.length === 4 ? `507-786-${phoneNumber}` : phoneNumber
}

function fixupEmailFormat(email) {
	if (!/@/.test(email)) {
		// No @ in address ... e.g. smith
		return `${email}@stolaf.edu`
	} else if (/@$/.test(email)) {
		// @ at end ... e.g. smith@
		return `${email}stolaf.edu`
	} else {
		// Defined address ... e.g. smith@stolaf.edu
		return email
	}
}

function nextPageExists(dom) {
	if (dom === undefined) {
		return false
	}

	const elements = dom.window.document.querySelectorAll('.next.page-numbers')
	return elements.length > 0
}

export function findPageUrls(dom) {
	const linkElements =[
		...dom.window.document.querySelectorAll('.gv-list-view > .gv-list-view-title > h3 > a')
	]

	return linkElements.map((url) => url.getAttribute('href'))
}

/**
 * The wp-json response now provides a much rougher response that requires a lot
 * of separate network requests that involve both json and html parsing in order
 * for us to deliver the full props for each job posting.
 * 
 * In short:
 * 1. [json] wp-json paginated requests to get page urls (1-3 requests for 25->50->75 entries)
 * 2. [html] detail page html requests, involves html parsing and returning json (easily 50+ requests)
 * 
 * We end up making multiple requests to the wp-json endpoint to build up all of
 * the top-level paginated urls, and then a request-per-post to get the details.
 */
async function _getJobs() {
	let allUrls = []

	// the paginator (as of writing) starts off at 25 entries
	// we are currently seeing 50 entries so we would expect to query this endpoint twice
	let pageNumber = 1

	let previousDom = undefined

	do {
		const response = await get(`${jobsUrl}?pagenum=${pageNumber}`, {json: true})
		const {rendered} = response.body.content
		
		const dom = new JSDOM(rendered, {contentType: 'text/html'})
		previousDom = dom
		pageNumber += 1

		const fetchedUrls = findPageUrls(dom)
		allUrls.push(...fetchedUrls)
	}
	while(nextPageExists(previousDom))

	return pMap(allUrls, fetchDetail, {concurrency: 4})
}

export const getJobs = mem(_getJobs, {maxAge: ONE_DAY})

export async function jobs(ctx) {
	ctx.cacheControl(ONE_DAY)

	ctx.body = await getJobs()
}
